pipeline {
    agent any

    options {
        disableConcurrentBuilds()
        timeout(time: 30, unit: 'MINUTES') // Cancela si tarda mÃ¡s de 30 min
    }

    environment {
        DOCKER_REPO = "mikeangeloo/apollo-frontend"  // Cambiar con tu repositorio de Docker
        BRANCH_NAME = sh(script: "echo ${env.GIT_BRANCH} | sed 's|^origin/||'", returnStdout: true).trim()
        BUILD_VERSION = "${env.BUILD_NUMBER}"    // NÃºmero Ãºnico de build de Jenkins

        GITHUB_REPO = 'CodiMex360/apollo-frontend' // Reemplaza con tu repositorio
        GITHUB_TOKEN = credentials('GITHUB_TOKEN')  // AquÃ­ usas el token configurado como credencial
        COMMIT_SHA = sh(script: "git rev-parse HEAD", returnStdout: true).trim()  // SHA del commit actual

        PACKAGE_VERSION = ''                     // AlmacenarÃ¡ la versiÃ³n del package.json
        IMAGE_TAG = ''                           // Etiqueta para la imagen Docker
        DOCKER_IMAGE = ''                        // Definiendo para guardar la referencia de la imagen de docker
    }

    stages {


        stage('Detectar PR con API') {
            steps {
                script {
                    def prData = getPRData()
                    if (prData) {
                        env.CHANGE_ID = prData.number
                        env.TARGET_BRANCH = prData.targetBranch
                        echo "âœ… Detectado PR: #${prData.number} con la rama de destino: ${prData.targetBranch}"
                    } else {
                        error "ðŸš¨ No se detectÃ³ PR asociado."
                    }
                }
            }
        }

        stage('Start') {
          steps {
            script {
              // Actualizamos el estado inicial a github
              updateGitHubCommitStatus('pending')

              echo "Pipeline iniciado para el commit ${COMMIT_SHA}"
            }
          }
        }

        stage('Checkout') {
            steps {
                checkout scm // Esta es la acciÃ³n para clonar el repositorio
                script {
                    echo "ðŸ“¥ Se han bajado los cambios de la rama ${BRANCH_NAME}"
                }
            }
        }

        stage('Obtener versiÃ³n del package.json y formar IMAGE_TAG') {
            steps {
                script {
                    // Obtener la versiÃ³n desde el archivo package.json
                    PACKAGE_VERSION = sh(script: "jq -r .version package.json", returnStdout: true).trim()
                    echo "ðŸ“Œ VersiÃ³n extraÃ­da: ${PACKAGE_VERSION}"

                    IMAGE_TAG = "${DOCKER_REPO}:${PACKAGE_VERSION}-${BUILD_VERSION}-${BRANCH_NAME}"
                }
            }
        }

        stage('Contruir imagen Docker') {
          agent { label 'docker-agent' }
          steps {
            script {
              // Construir la imagen Docker
              echo "ðŸš€ Construyendo imagen Docker..."
              DOCKER_IMAGE = docker.build("${IMAGE_TAG}")
            }
          }
        }

        //Descomentar en AWS
        // stage('Ejecutar pruebas unitarias') {
        //     agent { label 'docker-agent' }
        //     steps {
        //         script {
        //           if (DOCKER_IMAGE) {
        //             // Ejecutar las pruebas unitarias con Jest para Angular
        //             echo "âš¡ Ejecutando pruebas unitarias ..."
        //             DOCKER_IMAGE.inside {
        //                 // Posicionarse en el directorio correcto (aunque /app es el directorio de trabajo)
        //                 sh 'pwd'
        //                 sh 'ls -la'
        //                 sh 'npm run test:ci'  // Ejecutar pruebas unitarias

        //                 // Obtener la cobertura global desde el JSON de cobertura
        //                 def coverageJson = readJSON(file: 'coverage/coverage-summary.json')
        //                 def coverage = coverageJson.total.statements.pct  // Extrae el porcentaje de cobertura total

        //                 echo "ðŸ“Š Cobertura de cÃ³digo: ${coverage}%"

        //                 if (coverage.toFloat() < 80) {
        //                     error "ðŸš¨ Cobertura de pruebas menor al 80%. No se puede continuar con el pipeline."
        //                 }
        //             }
        //           } else {
        //             error "âŒ La imagen Docker no se construyÃ³ correctamente. El pipeline se detiene."
        //           }
        //         }
        //     }
        // }

        // stage('AnÃ¡lisis con SonarQube') {
        //     steps {
        //         script {
        //             // AnÃ¡lisis del cÃ³digo con SonarQube
        //             echo "ðŸ” Ejecutando anÃ¡lisis con SonarQube..."
        //             sh 'sonar-scanner'
        //         }
        //     }
        // }

        stage('Publicar imagen en Docker Hub') {
            agent { label 'docker-agent' }
            steps {
                script {
                    if (DOCKER_IMAGE) {
                       // AutenticaciÃ³n con Docker Hub y publicaciÃ³n de las imÃ¡genes
                        echo "ðŸ“¤ Publicando imagen en Docker Hub..."
                        withDockerRegistry([credentialsId: 'DOCKER_HUB_CRED']) {
                            echo "ðŸ“¤ Publicando imagen en Docker Hub..."
                             DOCKER_IMAGE.push()
                        }
                    } else {
                       error "âŒ La imagen Docker no se construyÃ³ correctamente. El pipeline se detiene."
                    }
                }
            }
        }

        stage('Desplegar en EKS') {
            steps {
                script {
                    // Desplegar en EKS para validar cambios (efÃ­mero)
                    echo "ðŸš€ Desplegando en EKS..."
                    sh "./scripts/deploy.sh pr-${BUILD_VERSION} ${IMAGE_TAG} host.docker.internal:8080"
                }
            }
        }

        stage('Eliminar Entorno EfÃ­mero') {
            when {
                expression {
                    // Si estamos en la rama destino, el PR fue fusionado
                    return env.GIT_BRANCH == "origin/${env.TARGET_BRANCH}"
                }
            }
            steps {
                script {
                    def namespace = "pr-${env.BUILD_VERSION}"
                    def imageTag = "${env.BUILD_VERSION}"
                    def deleteImage = "True"

                    echo "ðŸ”´ Eliminando entorno: ${namespace} con imagen ${imageTag}"

                    sh """
                        chmod +x ./scripts/delete.sh
                        ./scripts/delete.sh ${namespace} ${imageTag} ${deleteImage}
                    """
                }
            }
        }

    }

   post {
        success {
            script {
                // Actualizamos el estado del PR a 'success'
                echo 'Pipeline exitoso. Actualizando estado en GitHub.'
                updateGitHubCommitStatus('success')
            }
        }
        failure {
            script {
                // Actualizamos el estado del PR a 'failure'
                echo 'Pipeline fallido. Actualizando estado en GitHub.'
                updateGitHubCommitStatus('failure')
            }
        }
         aborted {
            script {
                updateGitHubCommitStatus('error')  // Actualiza el estado como cancelado
            }
        }
        always {
            script {
                // Este paso siempre se ejecutarÃ¡ al final, independientemente del resultado
                echo 'Finalizando el pipeline.'
            }
        }
   }
}

// FunciÃ³n personalizada para actualizar el estado del commit en GitHub
def updateGitHubCommitStatus(String status) {
    // FunciÃ³n para actualizar el estado del PR en GitHub
    echo "Actualizando el estado del PR en GitHub a: ${status}"
    withCredentials([string(credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN')]) {
        sh """
            curl -X POST -H "Authorization: token ${GITHUB_TOKEN}" \
            -d '{"state": "${status}", "target_url": "${JENKINS_URL}job/${JOB_NAME}/${BUILD_NUMBER}", "description": "Build ${status}", "context": "CI/CD Pipeline"}' \
            https://api.github.com/repos/${GITHUB_REPO}/statuses/${GIT_COMMIT}
        """
    }
}

def getPRData() {
    def response = sh(script: """
        curl -s -H "Authorization: token ${env.GITHUB_TOKEN}" \\
        "https://api.github.com/repos/${env.GITHUB_REPO}/pulls?state=open" | jq -r '.[] | select(.head.sha == "${env.GIT_COMMIT}") | {number, base: .base.ref}'
    """, returnStdout: true).trim()

    // Procesamos la respuesta JSON para obtener los valores especÃ­ficos
    def prNumber = sh(script: "echo '${response}' | jq -r '.number'", returnStdout: true).trim()
    def targetBranch = sh(script: "echo '${response}' | jq -r '.base.ref'", returnStdout: true).trim()

    if (prNumber && targetBranch) {
        return [
            number: prNumber,
            targetBranch: targetBranch
        ]
    } else {
        return null
    }
}
