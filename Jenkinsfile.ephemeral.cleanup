pipeline {
    agent any

    options {
        disableConcurrentBuilds()
        timeout(time: 30, unit: 'MINUTES')
    }

    environment {
        DOCKER_REPO = "mikeangeloo/apollo-frontend"  // Repositorio de Docker
        GITHUB_REPO = 'CodiMex360/apollo-frontend'
        GITHUB_TOKEN = credentials('GITHUB_TOKEN')
        COMMIT_SHA = sh(script: "git rev-parse HEAD", returnStdout: true).trim()

        PACKAGE_VERSION = ''   // Versi√≥n extra√≠da de package.json
        IMAGE_TAG = ''         // Etiqueta que se usar√° para la imagen Docker
        DOCKER_IMAGE = ''      // Referencia de la imagen Docker construida
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    deleteDir() // Limpia el workspace antes de clonar

                    echo "üîÑ Checkout de la rama ${env.BRANCH_NAME ?: 'master'}"
                    checkout scm

                    // Validar la rama final despu√©s del checkout
                    env.BRANCH_NAME = sh(script: "git rev-parse --abbrev-ref HEAD", returnStdout: true).trim()
                    echo "üì• Se han bajado los cambios de la rama ---> ${env.BRANCH_NAME}"
                }
            }
        }

        stage('Detectar PR con API') {
            steps {
                script {
                    def prData = getPRData()
                    if (prData) {
                        env.TAG_ID = prData.number
                        env.TARGET_BRANCH = prData.targetBranch
                        env.IS_PR = "true"
                        echo "‚úÖ Detectado PR: #${prData.number} con target branch ${prData.targetBranch}"
                    } else {
                        echo "No se detect√≥ PR, asumiendo merge a la target branch."
                        env.IS_PR = "false"
                    }
                }
            }
        }

        stage('Detectar Merge') {
            steps {
                script {
                    def commitMessage = sh(script: "git log -1 --pretty=%B", returnStdout: true).trim()
                    echo "Mensaje del √∫ltimo commit: ${commitMessage}"

                    // Expresi√≥n regular mejorada para capturar el n√∫mero del PR
                    def matcher = (commitMessage =~ /Merge pull request #(\d+) from/)
                    if (matcher.find()) {
                        env.TAG_ID = matcher.group(1)
                        echo "üöÄ Se detect√≥ un merge del PR #${env.TAG_ID}"
                    } else {
                        echo "‚ö†Ô∏è No se detect√≥ merge directo."
                    }
                }
            }
        }

        stage('Confirmar PR fusionado con GitHub API') {
            steps {
                script {
                    def mergedPR = sh(script: """
                        curl -s -H "Authorization: token ${env.GITHUB_TOKEN}" \\
                        "https://api.github.com/repos/${env.GITHUB_REPO}/pulls?state=closed" | jq -r '.[] | select(.merge_commit_sha == "${env.GIT_COMMIT}") | .number'
                    """, returnStdout: true).trim()

                    if (mergedPR) {
                        echo "‚úÖ Confirmado: PR #${mergedPR} fue fusionado"
                        env.TAG_ID = mergedPR
                    } else {
                        echo "‚ö†Ô∏è No se encontr√≥ el PR fusionado en la API."
                    }
                }
            }
        }

        stage('Start') {
            steps {
                script {
                    updateGitHubCommitStatus('pending')
                    echo "Pipeline iniciado para el commit ${COMMIT_SHA}"
                }
            }
        }

        stage('Validate env.TAG_ID') {
            steps {
              script {
                if (!env.TAG_ID) {
                  echo "üö´ Saltando ejecuci√≥n del pipeline, no se encontro un env.TAG_ID."
                  currentBuild.result = 'ABORTED'
                  return // Esto detiene la ejecuci√≥n
                }
              }
            }
        }

        stage('Obtener versi√≥n y formar IMAGE_TAG') {
           when {
                expression { return !!env.TAG_ID }
            }
            steps {
                script {
                    PACKAGE_VERSION = sh(script: "jq -r .version package.json", returnStdout: true).trim()
                    echo "üìå Versi√≥n extra√≠da: ${PACKAGE_VERSION}"
                    IMAGE_TAG = "${DOCKER_REPO}:${PACKAGE_VERSION}-${env.TAG_ID}"
                }
            }
        }

        stage('Eliminar Entorno Ef√≠mero') {
            when {
                expression { return env.IS_PR == "false" && !!env.TAG_ID }
            }
            steps {
                script {
                    def namespace = "pr-${env.TAG_ID}"
                    def imageTag = IMAGE_TAG
                    def deleteImage = "true"
                    // Usamos withCredentials para inyectar DOCKER_HUB_USER y DOCKER_HUB_PASS
                    withCredentials([usernamePassword(credentialsId: 'DOCKER_HUB_CRED', usernameVariable: 'DOCKER_HUB_USER', passwordVariable: 'DOCKER_HUB_PASS')]) {
                        // Ejecutamos el script que usa las credenciales inyectadas
                        sh """
                            echo "DOCKER_HUB_USER: ${DOCKER_HUB_USER}"
                            chmod +x ./k8s/scripts/delete.sh
                            ./k8s/scripts/delete.sh ${namespace} ${imageTag} ${deleteImage}
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            script {
                echo "Pipeline exitoso. Actualizando estado en GitHub a success."
                updateGitHubCommitStatus('success')
            }
        }
        failure {
            script {
                echo "Pipeline fallido. Actualizando estado en GitHub a failure."
                updateGitHubCommitStatus('failure')
            }
        }
        aborted {
            script {
                updateGitHubCommitStatus('error')
            }
        }
        always {
            script {
                echo "Finalizando el pipeline."
            }
        }
    }
}

// Funci√≥n para actualizar el estado del commit/PR en GitHub
def updateGitHubCommitStatus(String status) {
    echo "Actualizando el estado del commit en GitHub a: ${status}"
    withCredentials([string(credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN')]) {
        sh """
            curl -X POST -H "Authorization: token ${GITHUB_TOKEN}" \
            -d '{"state": "${status}", "target_url": "${JENKINS_URL}job/${JOB_NAME}/${BUILD_NUMBER}", "description": "Build ${status}", "context": "CI/CD Pipeline"}' \
            https://api.github.com/repos/${GITHUB_REPO}/statuses/${GIT_COMMIT}
        """
    }
}

// Funci√≥n para obtener datos del PR mediante la API de GitHub
def getPRData() {
    def response = sh(script: """
        curl -s -H "Authorization: token ${env.GITHUB_TOKEN}" \\
        "https://api.github.com/repos/${env.GITHUB_REPO}/pulls?state=open" | jq -r '.[] | select(.head.sha == "${env.GIT_COMMIT}") | {number, base: .base.ref}'
    """, returnStdout: true).trim()
    def prNumber = sh(script: "echo '${response}' | jq -r '.number'", returnStdout: true).trim()
    def targetBranch = sh(script: "echo '${response}' | jq -r '.base'", returnStdout: true).trim()
    if (prNumber && targetBranch) {
        return [ number: prNumber, targetBranch: targetBranch ]
    } else {
        return null
    }
}

def getLoadBalancerURL(namespace) {
    def retries = 3
    def waitTime = 10 // segundos entre cada intento
    def externalURL = ""

    for (int i = 0; i < retries; i++) {
        externalURL = sh(script: """
            kubectl get svc -n ${namespace} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' || echo ""
        """, returnStdout: true).trim()

        if (externalURL) {
            echo "‚úÖ LoadBalancer URL encontrado: ${externalURL}"
            return externalURL
        }

        echo "‚è≥ Esperando a que el LoadBalancer est√© listo... Intento ${i + 1} de ${retries}"
        sleep(waitTime)
    }

    echo "‚ùå No se pudo obtener la URL del LoadBalancer despu√©s de ${retries} intentos."
    return ""
}
